import { expect } from "chai";
import { EC } from "../src/crypto";
import { ZERO, ONE, NEGATIVE_ONE } from "../src/other/bigMath";

describe("EC", () => {
    describe("Private key", () => {
        it("creates random private key without seed", () => {
            for (let i = 0, a = EC.createPrivateKey(), b: EC.PrivateKey; b = EC.createPrivateKey(), i < 10; ++i, a = b)
                expect(b).not.equals(a, i.toString());
        });

        it("creates same private key with seed", () => {
            const seed = 55066263022277343669578718895168534326250603453777594175500187360389116729240n;

            for (let i = 0, a = EC.createPrivateKey(seed), b: EC.PrivateKey; b = EC.createPrivateKey(seed), i < 10; ++i, a = b)
                expect(b).equals(a, i.toString());
        });
    });

    describe("Point", () => {
        const tests = [
            { point: { x: 55066263022277343669578718895168534326250603453777594175500187360389116729240n, y: 32670510020758816978083085130507043184471273380659243275938904335757337482424n }, hex: '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8' },
            { point: { x: 100246798096428461162519094048188339919796084503065794421249584913901069554516n, y: 92940401690438524556628768650396950368558238091373243023688706168022980619777n }, hex: '04dda1ad50dc24112e1760cc63fb4a852c3b2f215bedfa845b04e6898500d45354cd7a6737f9b001ee94edd4ec6cc002abbc1289ee010092f67eefa86ac99fee01' },
            { point: { x: 75954223314970233398426753698682183949191480452811023032051325843390788425033n, y: 66204008983414722987897280229217393715894256628103286839634250651214827073419n }, hex: '04a7ec9122e7de457a15988527912f092e11685c58cfbb2d91afd0bf7204465549925e242536e7a168dca320e83ebc69b2a967cbd26350d6bbd732665d1051af8b' },
            { point: { x: 5865156646716975410776874341195495403915825609961865021496267323801432817065n, y: 113804691939730527909453370858120801114574084951639041697220995762996345802317n }, hex: '040cf78f9f1664f816a0da152513d9b9b699d140f7674e1c451a8495a07e48fda9fb9b2c4933090c83a137337506aef5428114827d2688379f307ff4bbfa3b8e4d' },
            { point: { x: 55066263022277343669578718895168534326250603453777594175500187360389116729240n, y: 83121579216557378445487899878180864668798711284981320763518679672151497189239n }, hex: '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798b7c52588d95c3b9aa25b0403f1eef75702e84bb7597aabe663b82f6f04ef2777' }
        ];

        it("serializes to hex", () => tests.forEach((test, index) => expect(new EC.Point(test.point.x, test.point.y).toHex()).equals(test.hex, index.toString())));
        it("deserialized from hex", () => tests.forEach((test, index) => expect(EC.Point.fromHex(test.hex)).deep.contains(test.point, index.toString())));
    });

    describe("secp256k1", () => {
        EC.secp256k1.prepare();

        it("creates public key", () => {
            [
                { k: ONE, result: { x: 55066263022277343669578718895168534326250603453777594175500187360389116729240n, y: 32670510020758816978083085130507043184471273380659243275938904335757337482424n } },
                { k: 69709824647410995196869881115846505901990055766378483939825846202281501673245n, result: { x: 100246798096428461162519094048188339919796084503065794421249584913901069554516n, y: 92940401690438524556628768650396950368558238091373243023688706168022980619777n } },
                { k: 45849928233752014892795207566246660205304640052988776961106790459616880739380n, result: { x: 75954223314970233398426753698682183949191480452811023032051325843390788425033n, y: 66204008983414722987897280229217393715894256628103286839634250651214827073419n } },
                { k: 92129844341223977202515445107227621807749999367575673736633558220612049744018n, result: { x: 5865156646716975410776874341195495403915825609961865021496267323801432817065n, y: 113804691939730527909453370858120801114574084951639041697220995762996345802317n } },
                { k: 115792089237316195423570985008687907852837564279074904382605163141518161494336n, result: { x: 55066263022277343669578718895168534326250603453777594175500187360389116729240n, y: 83121579216557378445487899878180864668798711284981320763518679672151497189239n } }
            ].forEach((test, index) => expect(EC.secp256k1.createPublicKey(test.k)).deep.contains(test.result, index.toString()));
        });

        it("catches invalid private keys", () => {
            [
                { k: NEGATIVE_ONE, result: 'private key must be > 0n' },
                { k: ZERO, result: 'private key must be > 0n' },
                { k: 115792089237316195423570985008687907852837564279074904382605163141518161494337n, result: 'private key must be < 115792089237316195423570985008687907852837564279074904382605163141518161494337n' },
            ].forEach((test, index) => expect(() => EC.secp256k1.createPublicKey(test.k)).throws(test.result, index.toString()));
        });
    });
});